'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _getTypeParameters = require('./getTypeParameters');

var _getTypeParameters2 = _interopRequireDefault(_getTypeParameters);

var _typeAnnotationIterator = require('./typeAnnotationIterator');

var _typeAnnotationIterator2 = _interopRequireDefault(_typeAnnotationIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var converters = {};

/**
 * Convert a type definition to a typed method call.
 */
function convert(context, path) {
  var converter = converters[path.type];
  if (!converter) {
    throw new Error('Unsupported node type: ' + path.type);
  }
  var loc = path.node.loc;
  var result = converter(context, path);
  if (result && loc) {
    result.loc = loc;
  }
  return result;
}

function annotationReferencesId(annotation, name) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _typeAnnotationIterator2.default)(annotation)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;

      if (item.type === 'Identifier' && item.node.name === name) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
}

/**
 * Determine whether a given type parameter exists in a position where
 * values it receives should flow into the union of types the annotation
 * allows. For example, given a function like `<T> (a: T, b: T) => T`,
 * T should be a union of whatever `a` and `b` are.
 *
 * If the annotation exists in a function parameter, it is considered flowable.
 */
function typeParameterCanFlow(annotation) {
  var subject = annotation.parentPath;
  while (subject) {
    if (subject.isClassProperty()) {
      return true;
    } else if (subject.isFlow()) {
      subject = subject.parentPath;
      continue;
    } else if (subject.isStatement()) {
      return false;
    }

    if (subject.isIdentifier() || subject.isArrayPattern() || subject.isObjectPattern()) {
      if (subject.parentPath.isFunction() && subject.listKey === 'params') {
        return true;
      }
    }
    subject = subject.parentPath;
  }

  return false;
}

function annotationParentHasTypeParameter(annotation, name) {
  var subject = annotation.parentPath;
  while (subject && subject.isFlow()) {
    var typeParameters = (0, _getTypeParameters2.default)(subject);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = typeParameters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var typeParameter = _step2.value;

        if (typeParameter.node.name === name) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    subject = subject.parentPath;
  }
  return false;
}

function parentIsStaticMethod(subject) {
  var fn = subject.findParent(function (item) {
    return item.isClassMethod();
  });
  if (!fn) {
    return false;
  }
  return fn.node.static;
}

function parentIsClassConstructorWithSuper(subject) {
  var fn = subject.findParent(function (item) {
    return item.isClassMethod() && item.node.kind === 'constructor';
  });
  if (!fn) {
    return false;
  }
  var classDefinition = fn.parentPath.parentPath;
  if (classDefinition.has('superClass')) {
    return true;
  } else {
    return parentIsClassConstructorWithSuper(classDefinition.parentPath);
  }
}

function qualifiedToMemberExpression(subject) {
  if (subject.type === 'QualifiedTypeIdentifier') {
    return t.memberExpression(qualifiedToMemberExpression(subject.qualification), subject.id);
  } else {
    return subject;
  }
}

function annotationToValue(subject) {
  switch (subject.type) {
    case 'NullableTypeAnnotation':
    case 'TypeAnnotation':
      return annotationToValue(subject.typeAnnotation);
    case 'GenericTypeAnnotation':
      return annotationToValue(subject.id);
    case 'QualifiedTypeIdentifier':
      return t.memberExpression(annotationToValue(subject.qualification), subject.id);
    case 'NullLiteralTypeAnnotation':
      return t.nullLiteral();
    case 'VoidTypeAnnotation':
      return t.identifier('undefined');
    case 'BooleanLiteralTypeAnnotation':
      return t.booleanLiteral(subject.value);
    case 'NumericLiteralTypeAnnotation':
      return t.numericLiteral(subject.value);
    case 'StringLiteralTypeAnnotation':
      return t.stringLiteral(subject.value);

    default:
      return subject;
  }
}

function getMemberExpressionObject(subject) {
  if (subject.type === 'MemberExpression') {
    return getMemberExpressionObject(subject.object);
  } else {
    return subject;
  }
}

converters.DeclareVariable = function (context, path) {
  var id = path.get('id');
  if (id.has('typeAnnotation')) {
    return context.call('declare', context.call('var', t.stringLiteral(id.node.name), convert(context, id.get('typeAnnotation'))));
  } else {
    return context.call('declare', context.call('var', t.stringLiteral(id.node.name)));
  }
};

converters.DeclareTypeAlias = function (context, path) {
  var id = path.get('id');
  var right = path.get('right');
  return context.call('declare', context.call('type', t.stringLiteral(id.node.name), convert(context, right)));
};

converters.DeclareFunction = function (context, path) {
  var id = path.get('id');
  if (id.has('typeAnnotation')) {
    return context.call('declare', t.stringLiteral(id.node.name), convert(context, id.get('typeAnnotation')));
  } else {
    return context.call('declare', t.stringLiteral(id.node.name));
  }
};

converters.DeclareModule = function (context, path) {
  var id = path.get('id');
  var name = id.isStringLiteral() ? id.node.value : id.node.name;
  return context.call('declare', context.call('module', t.stringLiteral(name), t.arrowFunctionExpression([t.identifier(context.libraryId)], t.blockStatement(path.get('body.body').map(function (item) {
    return t.expressionStatement(convert(context, item));
  })))));
};

converters.DeclareModuleExports = function (context, path) {
  return context.call('moduleExports', convert(context, path.get('typeAnnotation')));
};

converters.InterfaceDeclaration = function (context, path) {
  var name = path.node.id.name;
  var typeParameters = (0, _getTypeParameters2.default)(path);
  var body = convert(context, path.get('body'));
  if (typeParameters.length > 0) {
    body = t.arrowFunctionExpression([t.identifier(name)], t.blockStatement([t.variableDeclaration('const', typeParameters.map(function (typeParameter) {
      return t.variableDeclarator(t.identifier(typeParameter.node.name), t.callExpression(t.memberExpression(t.identifier(name), t.identifier('typeParameter')), typeParameter.node.bound ? [t.stringLiteral(typeParameter.node.name), convert(context, typeParameter.get('bound'))] : [t.stringLiteral(typeParameter.node.name)]));
    })), t.returnStatement(body)]));
  } else if (annotationReferencesId(path.get('body'), name)) {
    // This type alias references itself, we need to wrap it in an arrow
    body = t.arrowFunctionExpression([t.identifier(name)], t.blockStatement([t.returnStatement(body)]));
  }

  if (path.has('extends')) {
    body = context.call.apply(context, ['intersect'].concat(_toConsumableArray(path.get('extends').map(function (item) {
      return convert(context, item);
    })), [body]));
  }

  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier(name), context.call('type', t.stringLiteral(name), body))]);
};

converters.InterfaceExtends = function (context, path) {
  var id = path.get('id');
  var method = 'extends';
  if (path.parentPath.isInterfaceDeclaration()) {
    method = 'ref';
  }
  var name = void 0;
  var subject = void 0;
  if (id.isQualifiedTypeIdentifier()) {
    subject = qualifiedToMemberExpression(id.node);
    var outer = getMemberExpressionObject(subject);
    name = outer.name;
  } else {
    name = id.node.name;
    subject = t.identifier(name);
  }
  var typeParameters = (0, _getTypeParameters2.default)(path).map(function (item) {
    return convert(context, item);
  });
  var entity = context.getEntity(name, path);

  var isDirectlyReferenceable = annotationParentHasTypeParameter(path, name) || entity && (entity.isTypeAlias || entity.isTypeParameter);

  if (isDirectlyReferenceable) {
    if (typeParameters.length > 0) {
      return context.call.apply(context, [method, subject].concat(_toConsumableArray(typeParameters)));
    } else {
      return subject;
    }
  } else if (!entity) {
    return context.call.apply(context, [method, t.stringLiteral(name)].concat(_toConsumableArray(typeParameters)));
  } else {
    return context.call.apply(context, [method, subject].concat(_toConsumableArray(typeParameters)));
  }
};

converters.DeclareClass = function (context, path) {
  var id = path.get('id');
  var name = id.node.name;

  var extra = [];

  if (path.has('extends')) {
    var interfaceExtends = path.get('extends').map(function (item) {
      return convert(context, item);
    });
    extra.push.apply(extra, _toConsumableArray(interfaceExtends));
  }

  var typeParameters = (0, _getTypeParameters2.default)(path);
  if (typeParameters.length > 0) {
    var _ret = function () {
      var uid = path.scope.generateUidIdentifier(name);
      return {
        v: context.call('declare', context.call.apply(context, ['class', t.stringLiteral(name), t.arrowFunctionExpression([uid], t.blockStatement([t.variableDeclaration('const', typeParameters.map(function (typeParameter) {
          return t.variableDeclarator(t.identifier(typeParameter.node.name), t.callExpression(t.memberExpression(uid, t.identifier('typeParameter')), typeParameter.node.bound ? [t.stringLiteral(typeParameter.node.name), convert(context, typeParameter.get('bound'))] : [t.stringLiteral(typeParameter.node.name)]));
        })), t.returnStatement(convert(context, path.get('body')))]))].concat(extra)))
      };
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  } else {
    return context.call('declare', context.call.apply(context, ['class', t.stringLiteral(name), convert(context, path.get('body'))].concat(extra)));
  }
};

converters.TypeAlias = function (context, path) {
  var name = path.node.id.name;
  var typeParameters = (0, _getTypeParameters2.default)(path);
  var body = convert(context, path.get('right'));
  if (typeParameters.length > 0) {
    body = t.arrowFunctionExpression([t.identifier(name)], t.blockStatement([t.variableDeclaration('const', typeParameters.map(function (typeParameter) {
      return t.variableDeclarator(t.identifier(typeParameter.node.name), t.callExpression(t.memberExpression(t.identifier(name), t.identifier('typeParameter')), typeParameter.node.bound ? [t.stringLiteral(typeParameter.node.name), convert(context, typeParameter.get('bound'))] : [t.stringLiteral(typeParameter.node.name)]));
    })), t.returnStatement(body)]));
  } else if (annotationReferencesId(path.get('right'), path.node.id.name)) {
    // This type alias references itself, we need to wrap it in an arrow
    body = t.arrowFunctionExpression([t.identifier(name)], t.blockStatement([t.returnStatement(body)]));
  }
  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier(name), context.call('type', t.stringLiteral(name), body))]);
};

converters.TypeofTypeAnnotation = function (context, path) {
  return context.call('typeOf', annotationToValue(path.get('argument').node));
};

converters.TypeParameter = function (context, path) {
  if (path.has('bound')) {
    return context.call('typeParameter', t.stringLiteral(path.node.name), convert(context, path.get('bound')));
  } else {
    return context.call('typeParameter', t.stringLiteral(path.node.name));
  }
};

converters.TypeAnnotation = function (context, path) {
  return convert(context, path.get('typeAnnotation'));
};

converters.NullableTypeAnnotation = function (context, path) {
  return context.call('nullable', convert(context, path.get('typeAnnotation')));
};

converters.NullLiteralTypeAnnotation = function (context, _ref) {
  var node = _ref.node;

  return context.call('null');
};

converters.AnyTypeAnnotation = function (context, _ref2) {
  var node = _ref2.node;

  return context.call('any');
};

converters.MixedTypeAnnotation = function (context, _ref3) {
  var node = _ref3.node;

  return context.call('mixed');
};

converters.ExistentialTypeParam = function (context, _ref4) {
  var node = _ref4.node;

  return context.call('existential');
};

converters.EmptyTypeAnnotation = function (context, _ref5) {
  var node = _ref5.node;

  return context.call('empty');
};

converters.NumberTypeAnnotation = function (context, _ref6) {
  var node = _ref6.node;

  return context.call('number');
};

converters.NumericLiteralTypeAnnotation = function (context, _ref7) {
  var node = _ref7.node;

  return context.call('number', t.numericLiteral(node.value));
};

converters.BooleanTypeAnnotation = function (context, _ref8) {
  var node = _ref8.node;

  return context.call('boolean');
};

converters.BooleanLiteralTypeAnnotation = function (context, _ref9) {
  var node = _ref9.node;

  return context.call('boolean', t.booleanLiteral(node.value));
};

converters.StringTypeAnnotation = function (context, _ref10) {
  var node = _ref10.node;

  return context.call('string');
};

converters.StringLiteralTypeAnnotation = function (context, _ref11) {
  var node = _ref11.node;

  return context.call('string', t.stringLiteral(node.value));
};

converters.VoidTypeAnnotation = function (context, _ref12) {
  var node = _ref12.node;

  return context.call('void');
};

converters.UnionTypeAnnotation = function (context, path) {
  var types = path.get('types').map(function (item) {
    return convert(context, item);
  });
  return context.call.apply(context, ['union'].concat(_toConsumableArray(types)));
};

converters.IntersectionTypeAnnotation = function (context, path) {
  var types = path.get('types').map(function (item) {
    return convert(context, item);
  });
  return context.call.apply(context, ['intersection'].concat(_toConsumableArray(types)));
};

converters.GenericTypeAnnotation = function (context, path) {
  var id = path.get('id');
  var name = void 0;
  var subject = void 0;
  if (id.isQualifiedTypeIdentifier()) {
    subject = qualifiedToMemberExpression(id.node);
    var outer = getMemberExpressionObject(subject);
    name = outer.name;
  } else {
    name = id.node.name;
    subject = t.identifier(name);
  }
  if (context.shouldSuppressTypeName(name)) {
    return context.call('any');
  }
  if (context.isBoxed(id.node)) {
    subject = context.call('box', t.arrowFunctionExpression([], subject));
  }
  var typeParameters = (0, _getTypeParameters2.default)(path).map(function (item) {
    return convert(context, item);
  });
  var entity = context.getEntity(name, path);

  var isTypeParameter = entity && entity.isTypeParameter || annotationParentHasTypeParameter(path, name);

  if (isTypeParameter && typeParameterCanFlow(path)) {
    subject = context.call('flowInto', subject);
  }

  var isDirectlyReferenceable = isTypeParameter || entity && entity.isTypeAlias;

  if (isDirectlyReferenceable) {
    if (typeParameters.length > 0) {
      return context.call.apply(context, ['ref', subject].concat(_toConsumableArray(typeParameters)));
    } else {
      return subject;
    }
  } else if (!entity) {
    return context.call.apply(context, ['ref', t.stringLiteral(name)].concat(_toConsumableArray(typeParameters)));
  } else if (entity.isClassTypeParameter) {
    var target = void 0;
    var typeParametersUid = context.getClassData(path, 'typeParametersUid');
    var typeParametersSymbolUid = context.getClassData(path, 'typeParametersSymbolUid');
    if (typeParametersUid && parentIsStaticMethod(path)) {
      target = t.memberExpression(t.identifier(typeParametersUid), subject);
    } else if (typeParametersUid && parentIsClassConstructorWithSuper(path)) {
      target = t.memberExpression(t.identifier(typeParametersUid), subject);
    } else if (typeParametersSymbolUid) {
      target = t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(typeParametersSymbolUid), true), subject);
    } else {
      target = t.memberExpression(t.memberExpression(t.thisExpression(), t.memberExpression(t.thisExpression(), context.symbol('TypeParameters'), true), true), subject);
    }

    if (typeParameterCanFlow(path)) {
      target = context.call('flowInto', target);
    }

    if (typeParameters.length > 0) {
      return context.call.apply(context, ['ref', target].concat(_toConsumableArray(typeParameters)));
    } else {
      return target;
    }
  } else {
    if (name === 'Array') {
      return context.call.apply(context, ['array'].concat(_toConsumableArray(typeParameters)));
    }
    return context.call.apply(context, ['ref', subject].concat(_toConsumableArray(typeParameters)));
  }
};

converters.ArrayTypeAnnotation = function (context, path) {
  var elementType = convert(context, path.get('elementType'));
  return context.call('array', elementType);
};

converters.TupleTypeAnnotation = function (context, path) {
  var types = path.get('types').map(function (item) {
    return convert(context, item);
  });
  return context.call.apply(context, ['tuple'].concat(_toConsumableArray(types)));
};

converters.ObjectTypeAnnotation = function (context, path) {
  var body = [].concat(_toConsumableArray(path.get('callProperties')), _toConsumableArray(path.get('properties')), _toConsumableArray(path.get('indexers')));
  return context.call.apply(context, [path.node.exact ? 'exactObject' : 'object'].concat(_toConsumableArray(body.map(function (item) {
    return convert(context, item);
  }))));
};

converters.ObjectTypeCallProperty = function (context, path) {
  return context.call('callProperty', convert(context, path.get('value')));
};

converters.ObjectTypeProperty = function (context, path) {
  var propName = t.stringLiteral(path.node.key.name);
  var value = convert(context, path.get('value'));
  if (path.node.optional) {
    return context.call('property', propName, value, t.booleanLiteral(true));
  } else {
    return context.call('property', propName, value);
  }
};

converters.ObjectTypeIndexer = function (context, path) {
  return context.call('indexer', t.stringLiteral(path.node.id.name), convert(context, path.get('key')), convert(context, path.get('value')));
};

converters.FunctionTypeAnnotation = function (context, path) {
  var body = [].concat(_toConsumableArray(path.get('params').map(function (item) {
    return convert(context, item);
  })));
  if (path.has('rest')) {
    body.push(convert(context, path.get('rest')));
  }
  if (path.has('returnType')) {
    body.push(context.call('return', convert(context, path.get('returnType'))));
  }
  var typeParameters = (0, _getTypeParameters2.default)(path);
  if (typeParameters.length > 0) {
    var _ret2 = function () {
      var name = path.scope.generateUid('fn');
      return {
        v: context.call('function', t.arrowFunctionExpression([t.identifier(name)], t.blockStatement([t.variableDeclaration('const', typeParameters.map(function (typeParameter) {
          return t.variableDeclarator(t.identifier(typeParameter.node.name), t.callExpression(t.memberExpression(t.identifier(name), t.identifier('typeParameter')), typeParameter.node.bound ? [t.stringLiteral(typeParameter.node.name), convert(context, typeParameter.get('bound'))] : [t.stringLiteral(typeParameter.node.name)]));
        })), t.returnStatement(t.arrayExpression(body))])))
      };
    }();

    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
  } else {
    return context.call.apply(context, ['function'].concat(_toConsumableArray(body)));
  }
};

converters.FunctionTypeParam = function (context, path) {
  var _path$node = path.node,
      name = _path$node.name.name,
      optional = _path$node.optional;

  var args = [t.stringLiteral(name), convert(context, path.get('typeAnnotation'))];
  if (optional) {
    args.push(t.booleanLiteral(true));
  }
  if (path.key === 'rest') {
    return context.call.apply(context, ['rest'].concat(args));
  } else {
    return context.call.apply(context, ['param'].concat(args));
  }
};

converters.ClassProperty = function (context, path) {
  var typeAnnotation = path.has('typeAnnotation') ? convert(context, path.get('typeAnnotation')) : context.call('any');
  if (path.node.computed) {
    // make an object type indexer
    var keyType = context.call('union', context.call('number'), context.call('string'), context.call('symbol'));
    return context.call('indexer', t.stringLiteral('key'), keyType, typeAnnotation);
  } else {
    return context.call(path.node.static ? 'staticProperty' : 'property', t.stringLiteral(path.node.key.name), typeAnnotation);
  }
};

converters.ClassMethod = function (context, path) {
  var params = path.get('params').map(function (param) {
    if (param.isIdentifier()) {
      return context.call('param', t.stringLiteral(param.node.name), convert(context, param));
    } else if (param.isAssignmentPattern() && param.get('left').isIdentifier()) {
      return context.call('param', t.stringLiteral(param.node.left.name), convert(context, param));
    } else {
      return context.call('param', t.stringLiteral('_arg' + param.key), convert(context, param));
    }
  });
  var returnType = context.call('return', path.has('returnType') ? convert(context, path.get('returnType')) : context.call('any'));
  var args = [].concat(_toConsumableArray(params), [returnType]);
  if (path.node.computed) {
    // make an object type indexer.
    var keyType = context.call('union', context.call('number'), context.call('string'), context.call('symbol'));
    return context.call('indexer', t.stringLiteral('key'), keyType, context.call.apply(context, ['function'].concat(_toConsumableArray(args))));
  } else {
    return context.call.apply(context, [path.node.static ? 'staticMethod' : 'method', t.stringLiteral(path.node.key.name)].concat(_toConsumableArray(args)));
  }
};

converters.RestElement = function (context, path) {
  if (!path.has('typeAnnotation')) {
    return context.call('array', context.call('any'));
  } else {
    return convert(context, path.get('typeAnnotation'));
  }
};

converters.Identifier = function (context, path) {
  if (!path.has('typeAnnotation')) {
    return context.call('any');
  } else {
    return convert(context, path.get('typeAnnotation'));
  }
};

converters.ArrayPattern = function (context, path) {
  if (!path.has('typeAnnotation')) {
    return context.call('array', context.call('any'));
  } else {
    return convert(context, path.get('typeAnnotation'));
  }
};

converters.ObjectPattern = function (context, path) {
  if (!path.has('typeAnnotation')) {
    return context.call('ref', t.identifier('Object'));
  } else {
    return convert(context, path.get('typeAnnotation'));
  }
};

converters.AssignmentPattern = function (context, path) {
  return convert(context, path.get('left'));
};

exports.default = convert;