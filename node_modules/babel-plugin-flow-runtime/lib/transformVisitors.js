'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = transformVisitors;

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _typeAnnotationIterator = require('./typeAnnotationIterator');

var _typeAnnotationIterator2 = _interopRequireDefault(_typeAnnotationIterator);

var _convert = require('./convert');

var _convert2 = _interopRequireDefault(_convert);

var _attachImport = require('./attachImport');

var _attachImport2 = _interopRequireDefault(_attachImport);

var _getTypeParameters = require('./getTypeParameters');

var _getTypeParameters2 = _interopRequireDefault(_getTypeParameters);

var _assert = require('assert');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function transformVisitors(context) {
  var shouldCheck = context.shouldAssert || context.shouldWarn;
  var shouldAnnotate = context.shouldAnnotate;
  var nodeSignatures = new WeakMap();
  return {
    Program: function Program(path) {
      if (context.shouldImport) {
        (0, _attachImport2.default)(context, path);
      }
    },
    'Expression|Statement': function ExpressionStatement(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
    },
    'DeclareVariable|DeclareTypeAlias|DeclareFunction|DeclareClass|DeclareModule|InterfaceDeclaration': function DeclareVariableDeclareTypeAliasDeclareFunctionDeclareClassDeclareModuleInterfaceDeclaration(path) {
      if (context.shouldSuppressPath(path)) {
        return;
      }
      var replacement = (0, _convert2.default)(context, path);
      context.replacePath(path, replacement);
    },

    ImportDeclaration: {
      enter: function enter(path) {
        if (context.shouldSuppressPath(path)) {
          path.skip();
          return;
        }
      },
      exit: function exit(path) {
        if (path.node.importKind !== 'type') {
          return;
        }
        path.node.importKind = 'value';
      }
    },
    ExportDeclaration: {
      enter: function enter(path) {
        if (context.shouldSuppressPath(path)) {
          path.skip();
          return;
        }
      },
      exit: function exit(path) {
        if (path.node.exportKind !== 'type') {
          return;
        }
        path.node.exportKind = 'value';
      }
    },
    TypeAlias: function TypeAlias(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
      var replacement = (0, _convert2.default)(context, path);
      context.replacePath(path, replacement);
    },
    TypeCastExpression: function TypeCastExpression(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
      var expression = path.get('expression');
      var typeAnnotation = path.get('typeAnnotation');
      if (shouldCheck && !expression.isIdentifier()) {
        context.replacePath(path, context.assert((0, _convert2.default)(context, typeAnnotation), expression.node));
        return;
      }
      var name = expression.node.name;
      var binding = path.scope.getBinding(name);
      if (binding) {
        if (binding.path.isCatchClause()) {
          // special case typecasts for error handlers.
          context.replacePath(path.parentPath, t.ifStatement(t.unaryExpression('!', t.callExpression(t.memberExpression((0, _convert2.default)(context, typeAnnotation), t.identifier('accepts')), [expression.node])), t.blockStatement([t.throwStatement(expression.node)])));
          return;
        } else if (name === 'reify') {
          if (typeAnnotation.isTypeAnnotation()) {
            var annotation = typeAnnotation.get('typeAnnotation');
            var isTypeWrapper = annotation.isGenericTypeAnnotation() && annotation.node.id.name === 'Type' && annotation.node.typeParameters && annotation.node.typeParameters.params && annotation.node.typeParameters.params.length === 1;
            if (isTypeWrapper) {
              context.replacePath(path, (0, _convert2.default)(context, annotation.get('typeParameters.params')[0]));
              return;
            }
          }
          context.replacePath(path, (0, _convert2.default)(context, typeAnnotation));
          return;
        }
      }

      if (!path.parentPath.isExpressionStatement()) {
        if (!shouldCheck) {
          return;
        }
        // this typecast is part of a larger expression, just replace the value inline.
        context.replacePath(path, context.assert((0, _convert2.default)(context, typeAnnotation), expression.node));
        return;
      }

      var valueUid = path.scope.getData('valueUid:' + name);
      if (!valueUid) {
        valueUid = path.scope.generateUidIdentifier(name + 'Type');
        path.scope.setData('valueUid:' + name, valueUid);
        path.getStatementParent().insertBefore(t.variableDeclaration('let', [t.variableDeclarator(valueUid, (0, _convert2.default)(context, typeAnnotation))]));
      } else {
        path.getStatementParent().insertBefore(t.expressionStatement(t.assignmentExpression('=', valueUid, (0, _convert2.default)(context, typeAnnotation))));
      }
      if (shouldCheck) {
        context.replacePath(path, context.assert(valueUid, expression.node));
      } else {
        context.replacePath(path, expression.node);
      }
    },
    VariableDeclarator: function VariableDeclarator(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
      var id = path.get('id');
      if (!id.has('typeAnnotation')) {
        return;
      }
      if (!id.isIdentifier()) {
        (0, _assert.ok)(id.isArrayPattern() || id.isObjectPattern());
        var init = path.get('init');
        var wrapped = init.node;
        if (shouldCheck) {
          wrapped = context.assert((0, _convert2.default)(context, id.get('typeAnnotation')), wrapped);
        }
        if (wrapped !== init.node) {
          context.replacePath(init, wrapped);
        }
        return;
      }
      var name = id.node.name;


      if (!path.has('init') || path.parentPath.node.kind !== 'const') {
        var valueUid = path.scope.generateUidIdentifier(name + 'Type');
        path.scope.setData('valueUid:' + name, valueUid);
        path.insertBefore(t.variableDeclarator(valueUid, (0, _convert2.default)(context, id.get('typeAnnotation'))));
        if (shouldCheck && path.has('init')) {
          var _wrapped = context.assert(valueUid, path.get('init').node);

          context.replacePath(path, t.variableDeclarator(t.identifier(name), _wrapped));
        } else {
          context.replacePath(id, t.identifier(name));
        }
      } else if (shouldCheck) {
        var _wrapped2 = context.assert((0, _convert2.default)(context, id.get('typeAnnotation')), path.get('init').node);
        context.replacePath(path, t.variableDeclarator(t.identifier(name), _wrapped2));
      } else {
        context.replacePath(id, t.identifier(name));
      }
    },
    AssignmentExpression: function AssignmentExpression(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
      var left = path.get('left');
      if (!shouldCheck || !left.isIdentifier()) {
        return;
      }
      var name = left.node.name;
      var valueUid = path.scope.getData('valueUid:' + name);
      if (!valueUid) {
        return;
      }
      var right = path.get('right');
      context.replacePath(right, context.assert(valueUid, right.node));
    },

    Function: {
      enter: function enter(path) {
        if (context.shouldSuppressPath(path)) {
          path.skip();
          return;
        }
        if (context.visited.has(path.node)) {
          path.skip();
          return;
        }
        context.visited.add(path.node);
        var body = path.get('body');
        var definitions = [];
        var invocations = [];
        var typeParameters = (0, _getTypeParameters2.default)(path);
        var params = path.get('params');
        var signature = {
          isExpression: path.isExpression(),
          hasTypeAnnotations: false,
          typeParameters: [],
          params: [],
          returnType: null
        };
        nodeSignatures.set(path.node, signature);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = typeParameters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var typeParameter = _step.value;

            signature.hasTypeAnnotations = true;
            var _name = typeParameter.node.name;

            var args = [t.stringLiteral(_name)];
            if (typeParameter.has('bound')) {
              args.push((0, _convert2.default)(context, typeParameter.get('bound')));
            }
            definitions.push(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(_name), context.call.apply(context, ['typeParameter'].concat(args)))]));
            if (shouldAnnotate) {
              signature.typeParameters.push([_name, args]);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var shouldShadow = false;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = params[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var param = _step2.value;

            var argumentIndex = +param.key;
            var argumentName = void 0;
            var assignmentRight = void 0;
            if (param.isAssignmentPattern()) {
              assignmentRight = param.get('right');
              param = param.get('left');
            }

            if (param.isObjectPattern() || param.isArrayPattern()) {
              argumentName = '_arg' + (argumentIndex === 0 ? '' : argumentIndex);
            } else if (param.isRestElement()) {
              argumentName = param.node.argument.name;
            } else {
              argumentName = param.node.name;
            }

            if (!param.has('typeAnnotation')) {
              if (shouldAnnotate) {
                signature.params.push(context.call('param', t.stringLiteral(argumentName), context.call('any')));
              }
              continue;
            }
            var typeAnnotation = param.get('typeAnnotation');
            signature.hasTypeAnnotations = true;

            if (param.isObjectPattern() || param.isArrayPattern()) {
              if (shouldAnnotate) {
                signature.params.push(context.call('param', t.stringLiteral(argumentName), (0, _convert2.default)(context, typeAnnotation)));
              }
              if (shouldCheck) {
                shouldShadow = true;

                var _args = [t.stringLiteral('arguments[' + argumentIndex + ']'), (0, _convert2.default)(context, typeAnnotation)];
                if (param.has('optional')) {
                  _args.push(t.booleanLiteral(true));
                }

                var ref = t.memberExpression(t.identifier('arguments'), t.numericLiteral(argumentIndex), true);

                var expression = t.expressionStatement(context.assert(context.call.apply(context, ['param'].concat(_args)), ref));
                if (assignmentRight) {
                  invocations.push(t.ifStatement(t.binaryExpression('!==', ref, t.identifier('undefined')), t.blockStatement([expression])));
                } else {
                  invocations.push(expression);
                }
              }
            } else {
              var _name2 = param.node.name;
              var methodName = 'param';
              if (param.isRestElement()) {
                methodName = 'rest';
                _name2 = param.node.argument.name;
                if (shouldAnnotate) {
                  signature.params.push(context.call('rest', t.stringLiteral(_name2), (0, _convert2.default)(context, typeAnnotation)));
                }
              } else {
                (0, _assert.ok)(param.isIdentifier(), 'Param must be an identifier');
                if (shouldAnnotate) {
                  signature.params.push(context.call('param', t.stringLiteral(_name2), (0, _convert2.default)(context, typeAnnotation)));
                }
              }
              if (shouldCheck) {
                var valueUid = body.scope.generateUidIdentifier(_name2 + 'Type');
                body.scope.setData('valueUid:' + _name2, valueUid);
                definitions.push(t.variableDeclaration('let', [t.variableDeclarator(valueUid, (0, _convert2.default)(context, typeAnnotation))]));
                var _args2 = [t.stringLiteral(_name2), valueUid];
                if (param.has('optional')) {
                  _args2.push(t.booleanLiteral(true));
                }
                invocations.push(t.expressionStatement(context.assert(context.call.apply(context, [methodName].concat(_args2)), t.identifier(_name2))));
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (path.has('returnType')) {
          signature.hasTypeAnnotations = true;
          var _returnType = path.get('returnType');
          if (_returnType.type === 'TypeAnnotation') {
            _returnType = _returnType.get('typeAnnotation');
          }
          if (shouldAnnotate) {
            signature.returnType = context.call('return', (0, _convert2.default)(context, _returnType));
          }
          if (!shouldCheck) {
            // nothing left to do
            return;
          }
          var returnTypeParameters = (0, _getTypeParameters2.default)(_returnType);
          if (_returnType.isGenericTypeAnnotation() && returnTypeParameters.length > 0) {
            // If we're in an async function, make the return type the promise resolution type.
            if (path.node.async) {
              // @todo warn if identifier is not Promise ?
              _returnType = (0, _getTypeParameters2.default)(_returnType)[0];
            } else if (path.node.generator) {
              var yieldType = returnTypeParameters[0];
              _returnType = returnTypeParameters[1];
              var nextType = returnTypeParameters[2];
              var yieldTypeUid = body.scope.generateUidIdentifier('yieldType');
              body.scope.setData('yieldTypeUid', yieldTypeUid);
              definitions.push(t.variableDeclaration('const', [t.variableDeclarator(yieldTypeUid, (0, _convert2.default)(context, yieldType))]));
              var nextTypeUid = body.scope.generateUidIdentifier('nextType');
              body.scope.setData('nextTypeUid', nextTypeUid);
              definitions.push(t.variableDeclaration('const', [t.variableDeclarator(nextTypeUid, (0, _convert2.default)(context, nextType))]));
            }
          }
          var returnTypeUid = body.scope.generateUidIdentifier('returnType');
          body.scope.setData('returnTypeUid', returnTypeUid);
          definitions.push(t.variableDeclaration('const', [t.variableDeclarator(returnTypeUid, context.call('return', (0, _convert2.default)(context, _returnType)))]));
        }
        if (definitions.length > 0 || invocations.length > 0) {

          if (shouldShadow && path.isArrowFunctionExpression()) {
            path.arrowFunctionToShadowed();
            path.get('body').unshiftContainer('body', definitions.concat(invocations));
          } else {
            body.unshiftContainer('body', definitions.concat(invocations));
          }
        }
      },
      exit: function exit(path) {
        var signature = nodeSignatures.get(path.node);
        if (!shouldAnnotate || !signature || !Array.isArray(signature.params) || !signature.hasTypeAnnotations || path.isClassMethod()) {
          return;
        }
        var decoration = void 0;
        var block = [].concat(_toConsumableArray(signature.params));
        if (signature.returnType) {
          block.push(signature.returnType);
        }
        if (signature.typeParameters.length > 0) {
          (function () {
            var fn = path.scope.generateUidIdentifier('fn');
            decoration = context.call('function', t.arrowFunctionExpression([fn], t.blockStatement([].concat(_toConsumableArray(signature.typeParameters.map(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  name = _ref2[0],
                  args = _ref2[1];

              return t.variableDeclaration('const', [t.variableDeclarator(t.identifier(name), t.callExpression(t.memberExpression(fn, t.identifier('typeParameter')), args))]);
            })), [t.returnStatement(t.arrayExpression(block))]))));
          })();
        } else {
          decoration = context.call.apply(context, ['function'].concat(_toConsumableArray(block)));
        }
        if (signature.isExpression) {
          var replacement = context.call('annotate', path.node, decoration);
          context.replacePath(path, replacement);
        } else if (path.has('id')) {
          var _replacement = t.expressionStatement(context.call('annotate', path.node.id, decoration));
          if (path.parentPath.isExportDefaultDeclaration() || path.parentPath.isExportDeclaration()) {
            path.parentPath.insertAfter(_replacement);
          } else {
            path.insertAfter(_replacement);
          }
        } else if (path.isFunctionDeclaration()) {
          // we don't have an id, so we're probably an `export default function () {}`
          if (path.parentPath.isExportDefaultDeclaration()) {
            // @fixme - this is not nice, we just turn the declaration into an expression.
            path.node.type = 'FunctionExpression';
            path.node.expression = true;
            var _replacement2 = t.exportDefaultDeclaration(context.call('annotate', path.node, decoration));
            context.replacePath(path.parentPath, _replacement2);
          }
        }
      }
    },

    ReturnStatement: function ReturnStatement(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
      var fn = path.scope.getFunctionParent().path;
      if (!shouldCheck || !fn.has('returnType')) {
        return;
      }
      var returnTypeUid = path.scope.getData('returnTypeUid');

      var argument = path.get('argument');
      context.replacePath(argument, context.assert.apply(context, [returnTypeUid].concat(_toConsumableArray(argument.node ? [argument.node] : []))));
    },
    YieldExpression: function YieldExpression(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
      var fn = path.scope.getFunctionParent().path;
      if (!shouldCheck || !fn.has('returnType')) {
        return;
      }
      if (context.visited.has(path.node)) {
        return;
      }
      var yieldTypeUid = path.scope.getData('yieldTypeUid');
      var nextTypeUid = path.scope.getData('nextTypeUid');

      var argument = path.get('argument');
      var replacement = void 0;
      if (path.node.delegate) {
        replacement = t.yieldExpression(t.callExpression(context.call('wrapIterator', yieldTypeUid), argument.node ? [argument.node] : []), true);
      } else {
        replacement = t.yieldExpression(context.assert.apply(context, [yieldTypeUid].concat(_toConsumableArray(argument.node ? [argument.node] : []))));
      }

      context.visited.add(replacement);
      if (path.parentPath.isExpressionStatement()) {
        context.replacePath(path, replacement);
      } else {
        context.replacePath(path, context.assert(nextTypeUid, replacement));
      }
    },


    Class: {
      enter: function enter(path) {
        if (context.shouldSuppressPath(path)) {
          path.skip();
          return;
        }
        var signature = {
          name: path.has('id') ? path.node.id.name : 'AnonymousClass',
          isExpression: path.isExpression(),
          hasTypeAnnotations: false,
          typeParameters: [],
          properties: [],
          methods: [],
          extends: null
        };
        nodeSignatures.set(path.node, signature);

        var body = path.get('body');

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = body.get('body')[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var child = _step3.value;

            if (child.isClassMethod()) {
              signature.methods.push((0, _convert2.default)(context, child));
            } else if (child.isClassProperty()) {
              signature.properties.push((0, _convert2.default)(context, child));
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var typeParametersSymbolUid = context.getClassData(path, 'typeParametersSymbolUid');

        if (typeParametersSymbolUid) {
          path.getStatementParent().insertBefore(t.variableDeclaration('const', [t.VariableDeclarator(t.identifier(typeParametersSymbolUid), t.callExpression(t.identifier('Symbol'), [t.stringLiteral(context.getClassData(path, 'currentClassName') + 'TypeParameters')]))]));

          var staticProp = t.classProperty(context.symbol('TypeParameters'), t.identifier(typeParametersSymbolUid));
          staticProp.computed = true;
          staticProp.static = true;
          body.unshiftContainer('body', staticProp);
        }

        var superTypeParameters = path.has('superTypeParameters') ? path.get('superTypeParameters.params') : [];

        var hasSuperTypeParameters = superTypeParameters.length > 0;
        if (path.has('superClass')) {
          if (hasSuperTypeParameters) {
            signature.extends = context.call.apply(context, ['extends', path.node.superClass].concat(_toConsumableArray(superTypeParameters.map(function (item) {
              return (0, _convert2.default)(context, item);
            }))));
          } else {
            signature.extends = context.call('extends', path.node.superClass);
          }

          if (isReactComponentClass(path.get('superClass'))) {
            var annotation = hasSuperTypeParameters ? superTypeParameters[1] : getClassPropertyAnnotation(path, 'props');

            if (annotation) {
              var propTypes = t.classProperty(t.identifier('propTypes'), context.call('propTypes', (0, _convert2.default)(context, annotation)));
              propTypes.static = true;
              body.unshiftContainer('body', propTypes);
            }
          }
        }
      },
      exit: function exit(path) {
        var typeParameters = (0, _getTypeParameters2.default)(path);
        var superTypeParameters = path.has('superTypeParameters') ? path.get('superTypeParameters.params') : [];
        var hasTypeParameters = typeParameters.length > 0;
        var hasSuperTypeParameters = superTypeParameters.length > 0;
        var signature = nodeSignatures.get(path.node);
        if (shouldAnnotate && signature) {
          var _ref3 = signature,
              _name3 = _ref3.name,
              _properties = _ref3.properties,
              _methods = _ref3.methods;

          var args = _properties.concat(_methods);
          if (signature.extends) {
            args.push(signature.extends);
          }
          var decorator = t.decorator(context.call('annotate', context.call.apply(context, ['class', t.stringLiteral(_name3)].concat(_toConsumableArray(args)))));
          if (!path.has('decorators')) {
            path.node.decorators = [];
          }
          path.unshiftContainer('decorators', decorator);
        }
        if (!shouldCheck || !hasTypeParameters && !hasSuperTypeParameters) {
          // Nothing to do here.
          return;
        }

        var _path$get$filter = path.get('body.body').filter(function (item) {
          return item.node.kind === 'constructor';
        }),
            _path$get$filter2 = _slicedToArray(_path$get$filter, 1),
            constructor = _path$get$filter2[0];

        var typeParametersUid = t.identifier(context.getClassData(path, 'typeParametersUid'));
        var typeParametersSymbolUid = t.identifier(context.getClassData(path, 'typeParametersSymbolUid'));

        var thisTypeParameters = t.memberExpression(t.thisExpression(), typeParametersSymbolUid, true);

        if (path.has('superClass')) {
          var body = constructor.get('body');

          var trailer = [];
          if (hasTypeParameters) {
            body.unshiftContainer('body', t.variableDeclaration('const', [t.variableDeclarator(typeParametersUid, t.objectExpression(typeParameters.map(function (typeParameter) {
              return t.objectProperty(t.identifier(typeParameter.node.name), (0, _convert2.default)(context, typeParameter));
            })))]));

            trailer.push(t.expressionStatement(t.assignmentExpression('=', thisTypeParameters, typeParametersUid)));
          }

          if (hasSuperTypeParameters) {
            trailer.push(t.expressionStatement(context.call.apply(context, ['bindTypeParameters', t.thisExpression()].concat(_toConsumableArray(superTypeParameters.map(function (item) {
              return (0, _convert2.default)(context, item);
            }))))));
          }
          getSuperStatement(body).insertAfter(trailer);
        } else {
          constructor.get('body').unshiftContainer('body', t.expressionStatement(t.assignmentExpression('=', thisTypeParameters, t.objectExpression(typeParameters.map(function (typeParameter) {
            return t.objectProperty(t.identifier(typeParameter.node.name), (0, _convert2.default)(context, typeParameter));
          })))));
        }
        var staticMethods = path.get('body.body').filter(function (item) {
          return item.isClassMethod() && item.node.static;
        });

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = staticMethods[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var method = _step4.value;

            method.get('body').unshiftContainer('body', t.variableDeclaration('const', [t.variableDeclarator(typeParametersUid, t.objectExpression(typeParameters.map(function (typeParameter) {
              return t.objectProperty(t.identifier(typeParameter.node.name), (0, _convert2.default)(context, typeParameter));
            })))]));
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    },

    ClassProperty: function ClassProperty(path) {
      if (context.shouldSuppressPath(path)) {
        path.skip();
        return;
      }
      if (!shouldCheck || !path.has('typeAnnotation') || path.node.computed) {
        return;
      }
      var typeAnnotation = path.get('typeAnnotation');
      var decorator = void 0;
      if (annotationReferencesClassEntity(context, typeAnnotation)) {
        var args = [t.functionExpression(null, [], t.blockStatement([t.returnStatement((0, _convert2.default)(context, typeAnnotation))]))];
        if (context.shouldWarn) {
          args.push(t.booleanLiteral(false));
        }
        decorator = t.decorator(context.call.apply(context, ['decorate'].concat(args)));
      } else if (context.shouldWarn) {
        decorator = t.decorator(context.call('decorate', (0, _convert2.default)(context, typeAnnotation), t.booleanLiteral(false)));
      } else {
        decorator = t.decorator(context.call('decorate', (0, _convert2.default)(context, typeAnnotation)));
      }
      if (!path.has('decorators')) {
        path.node.decorators = [];
      }
      path.unshiftContainer('decorators', decorator);
    }
  };
}

function isReactComponentClass(path) {
  if (path.isIdentifier()) {
    return path.node.name === path.scope.getData('reactComponentClass') || path.node.name === path.scope.getData('reactPureComponentClass');
  } else if (path.isMemberExpression() && !path.node.computed) {
    var object = path.get('object');
    var property = path.get('property');
    if (!object.isIdentifier() || object.node.name !== path.scope.getData('reactLib')) {
      return false;
    }
    return property.isIdentifier() && (property.node.name === 'Component' || property.node.name === 'PureComponent');
  } else {
    return false;
  }
}

function getClassPropertyAnnotation(path, name) {
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = path.get('body.body')[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var item = _step5.value;

      if (item.isClassProperty() && item.node.key.name === name) {
        return item.get('typeAnnotation');
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }
}

function annotationReferencesClassEntity(context, annotation) {
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = (0, _typeAnnotationIterator2.default)(annotation)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var item = _step6.value;

      if (item.type !== 'Identifier') {
        continue;
      }
      var entity = context.getEntity(item.node.name, annotation);
      if (entity && entity.isClassTypeParameter) {
        return true;
      } else if (entity && entity.isValue && !entity.isGlobal) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6.return) {
        _iterator6.return();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  return false;
}

function getSuperStatement(block) {
  var found = void 0;
  block.traverse({
    Super: function Super(path) {
      found = path.getStatementParent();
    }
  });
  (0, _assert.ok)(found, "Constructor of sub class must contain super().");
  return found;
}